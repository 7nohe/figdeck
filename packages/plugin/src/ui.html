<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 16px;
      margin: 0;
    }
    form {
      margin: 0;
    }
    .tabs {
      display: flex;
      gap: 0;
      margin-bottom: 12px;
      border-bottom: 1px solid #ddd;
    }
    .tab {
      padding: 8px 16px;
      font-size: 13px;
      cursor: pointer;
      border: none;
      background: none;
      color: #666;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
    }
    .tab.active {
      color: #1a73e8;
      border-bottom-color: #1a73e8;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .connection {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-end;
      margin-bottom: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: #444;
    }
    .field input {
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
    }
    .connection button {
      padding: 8px 10px;
      font-size: 13px;
      border: 1px solid #1a73e8;
      background: #1a73e8;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }
    .connection button:active {
      transform: translateY(1px);
    }
    .field.secret-field {
      flex-grow: 1;
    }
    .field.secret-field input {
      width: 100%;
    }
    .warning-banner {
      background: #fff3cd;
      color: #856404;
      padding: 8px 12px;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 12px;
      display: none;
    }
    .warning-banner.visible {
      display: block;
    }
    .version-warning {
      background: #f8d7da;
      color: #721c24;
      padding: 8px 12px;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 12px;
      display: none;
    }
    .version-warning.visible {
      display: block;
    }
    .version-warning.info {
      background: #cce5ff;
      color: #004085;
    }
    .version-warning .dismiss {
      float: right;
      cursor: pointer;
      font-weight: bold;
      margin-left: 8px;
    }
    .import-section {
      margin-bottom: 12px;
    }
    .import-section textarea {
      width: 100%;
      min-height: 100px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      resize: vertical;
      box-sizing: border-box;
    }
    .import-section .buttons {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    .import-section button {
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid #1a73e8;
      background: #1a73e8;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }
    .import-section button.secondary {
      background: #fff;
      color: #1a73e8;
    }
    .import-section button:active {
      transform: translateY(1px);
    }
    .import-section input[type="file"] {
      display: none;
    }
    .status {
      padding: 8px 12px;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 13px;
    }
    .status.connected {
      background: #d4edda;
      color: #155724;
    }
    .status.disconnected {
      background: #f8d7da;
      color: #721c24;
    }
    .status.waiting {
      background: #fff3cd;
      color: #856404;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    .log {
      font-size: 12px;
      color: #666;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 8px;
      border-radius: 4px;
      background: #f9f9f9;
    }
    .log-entry {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <div class="tabs">
    <button class="tab active" data-tab="websocket">WebSocket</button>
    <button class="tab" data-tab="import">Import JSON</button>
  </div>

  <div id="tab-websocket" class="tab-content active">
    <div id="version-warning" class="version-warning">
      <span class="dismiss" onclick="dismissVersionWarning()">×</span>
      <span id="version-warning-text"></span>
    </div>
    <div id="remote-warning" class="warning-banner">
      ⚠️ Connecting to non-loopback host. Ensure you trust this server.
    </div>
    <form id="connection-form" class="connection">
      <label class="field">
        <span>Host</span>
        <input id="host" name="host" type="text" placeholder="127.0.0.1" autocomplete="off">
      </label>
      <label class="field">
        <span>Port</span>
        <input id="port" name="port" type="number" min="1" max="65535" placeholder="4141" autocomplete="off">
      </label>
      <label class="field secret-field">
        <span>Secret (optional)</span>
        <input id="secret" name="secret" type="text" placeholder="Auth secret from CLI" autocomplete="off">
      </label>
      <button id="connect" type="button">Connect</button>
    </form>
    <div id="status" class="status waiting">Connecting to WebSocket server...</div>
  </div>

  <div id="tab-import" class="tab-content">
    <div class="import-section">
      <textarea id="json-input" placeholder="Paste JSON slides array here..."></textarea>
      <div class="buttons">
        <button id="import-json" type="button">Generate Slides</button>
        <button id="load-file" type="button" class="secondary">Load File</button>
        <input type="file" id="file-input" accept=".json">
      </div>
    </div>
    <div id="import-status" class="status" style="display: none;"></div>
  </div>

  <div id="log" class="log" style="display: none;"></div>

  <script>
    var DEFAULT_HOST = '127.0.0.1';
    var DEFAULT_PORT = 4141;
    var HOST_KEY = 'figdeck-ws-host';
    var PORT_KEY = 'figdeck-ws-port';
    var SECRET_KEY = 'figdeck-ws-secret';
    var TAB_KEY = 'figdeck-active-tab';

    // Version compatibility
    var PROTOCOL_VERSION = '1';
    var PLUGIN_VERSION = '1.1.0';

    // Security limits
    var MAX_SLIDES = 100;
    var MAX_BLOCKS_PER_SLIDE = 50;
    var MAX_STRING_LENGTH = 100000;
    var MAX_LOG_ENTRIES = 100;

    var statusEl = document.getElementById('status');
    var importStatusEl = document.getElementById('import-status');
    var logEl = document.getElementById('log');
    var versionWarningEl = document.getElementById('version-warning');
    var versionWarningTextEl = document.getElementById('version-warning-text');
    var hostInput = document.getElementById('host');
    var portInput = document.getElementById('port');
    var secretInput = document.getElementById('secret');
    var remoteWarning = document.getElementById('remote-warning');
    var form = document.getElementById('connection-form');
    var connectButton = document.getElementById('connect');
    var jsonInput = document.getElementById('json-input');
    var importButton = document.getElementById('import-json');
    var loadFileButton = document.getElementById('load-file');
    var fileInput = document.getElementById('file-input');
    var tabs = document.querySelectorAll('.tab');
    var tabContents = document.querySelectorAll('.tab-content');
    var ws = null;
    var currentHost = DEFAULT_HOST;
    var currentPort = DEFAULT_PORT;
    var currentSecret = '';
    var activeTab = 'websocket';
    var autoConnect = true;
    var authenticated = false;
    var logEntryCount = 0;
    var helloReceived = false;
    var helloTimeoutId = null;
    var HELLO_TIMEOUT_MS = 3000;

    function safeGet(key) {
      try {
        return localStorage.getItem(key);
      } catch (e) {
        return null;
      }
    }

    function safeSet(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        // Ignore storage failures (e.g., sandboxed environments)
      }
    }

    function isLoopbackHost(host) {
      return host === '127.0.0.1' || host === '::1' || host === 'localhost';
    }

    function updateRemoteWarning() {
      if (isLoopbackHost(currentHost)) {
        remoteWarning.classList.remove('visible');
      } else {
        remoteWarning.classList.add('visible');
      }
    }

    function showVersionWarning(message, isInfo) {
      versionWarningTextEl.textContent = message;
      versionWarningEl.classList.remove('info');
      if (isInfo) {
        versionWarningEl.classList.add('info');
      }
      versionWarningEl.classList.add('visible');
    }

    function dismissVersionWarning() {
      versionWarningEl.classList.remove('visible');
    }

    function handleHelloMessage(msg) {
      helloReceived = true;
      if (helloTimeoutId) {
        clearTimeout(helloTimeoutId);
        helloTimeoutId = null;
      }

      var cliVersion = msg.cliVersion;
      var cliProtocol = msg.protocolVersion;

      log('CLI version: ' + cliVersion + ', Protocol: ' + cliProtocol);

      // Send hello response
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'hello',
          protocolVersion: PROTOCOL_VERSION,
          pluginVersion: PLUGIN_VERSION
        }));
      }

      // Check protocol version compatibility
      if (cliProtocol !== PROTOCOL_VERSION) {
        showVersionWarning(
          'Protocol version mismatch: CLI=' + cliProtocol + ', Plugin=' + PROTOCOL_VERSION + '. ' +
          'Update both to the same version to avoid compatibility issues.',
          false
        );
        log('[WARNING] Protocol version mismatch');
      } else if (cliVersion !== PLUGIN_VERSION) {
        showVersionWarning(
          'Version difference: CLI=' + cliVersion + ', Plugin=' + PLUGIN_VERSION + '. ' +
          'Consider updating to ensure compatibility.',
          true
        );
        log('[INFO] Version difference detected');
      } else {
        dismissVersionWarning();
        log('Version check passed');
      }
    }

    function startHelloTimeout() {
      helloReceived = false;
      if (helloTimeoutId) {
        clearTimeout(helloTimeoutId);
      }
      helloTimeoutId = setTimeout(function() {
        if (!helloReceived && ws && ws.readyState === WebSocket.OPEN) {
          showVersionWarning(
            'CLI version unknown (older CLI detected). Consider updating figdeck CLI for better compatibility.',
            true
          );
          log('[INFO] No hello received from CLI - possibly older version');
        }
      }, HELLO_TIMEOUT_MS);
    }

    function clearHelloTimeout() {
      if (helloTimeoutId) {
        clearTimeout(helloTimeoutId);
        helloTimeoutId = null;
      }
    }

    function log(message) {
      // Limit log entries to prevent memory growth
      if (logEntryCount >= MAX_LOG_ENTRIES) {
        var firstEntry = logEl.querySelector('.log-entry');
        if (firstEntry) {
          logEl.removeChild(firstEntry);
          logEntryCount--;
        }
      }
      var entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
      logEntryCount++;
    }

    function setStatus(text, className) {
      statusEl.textContent = text;
      statusEl.className = 'status ' + className;
    }

    function setImportStatus(text, className) {
      importStatusEl.textContent = text;
      importStatusEl.className = 'status ' + className;
      importStatusEl.style.display = text ? 'block' : 'none';
    }

    function switchTab(tabName) {
      activeTab = tabName;
      safeSet(TAB_KEY, tabName);

      tabs.forEach(function(tab) {
        if (tab.getAttribute('data-tab') === tabName) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });

      tabContents.forEach(function(content) {
        if (content.id === 'tab-' + tabName) {
          content.classList.add('active');
        } else {
          content.classList.remove('active');
        }
      });

      // Show/hide log based on tab
      logEl.style.display = tabName === 'websocket' ? 'block' : 'none';

      // Stop auto-reconnect when on import tab
      if (tabName === 'import' && ws) {
        autoConnect = false;
        ws.onclose = null;
        ws.close();
        ws = null;
      } else if (tabName === 'websocket') {
        autoConnect = true;
        connect(currentHost, currentPort, currentSecret);
      }
    }

    function loadStoredConnection() {
      var storedHost = safeGet(HOST_KEY);
      var storedPort = parseInt(safeGet(PORT_KEY) || '', 10);
      var storedSecret = safeGet(SECRET_KEY);
      var storedTab = safeGet(TAB_KEY);

      currentHost = storedHost && storedHost.trim() ? storedHost.trim() : DEFAULT_HOST;
      currentPort = Number.isFinite(storedPort) ? storedPort : DEFAULT_PORT;
      currentSecret = storedSecret || '';

      hostInput.value = currentHost;
      portInput.value = String(currentPort);
      secretInput.value = currentSecret;

      updateRemoteWarning();

      if (storedTab === 'import') {
        autoConnect = false;
        switchTab('import');
      }
    }

    function truncateString(str, maxLen) {
      if (typeof str !== 'string') return str;
      if (str.length > maxLen) {
        return str.slice(0, maxLen) + '... (truncated)';
      }
      return str;
    }

    function validateSlides(slides) {
      if (!Array.isArray(slides)) {
        return { valid: false, error: 'JSON must be an array of slides' };
      }
      if (slides.length === 0) {
        return { valid: false, error: 'Slides array is empty' };
      }
      if (slides.length > MAX_SLIDES) {
        return { valid: false, error: 'Too many slides (max: ' + MAX_SLIDES + ')' };
      }
      for (var i = 0; i < slides.length; i++) {
        var slide = slides[i];
        if (!slide || typeof slide !== 'object') {
          return { valid: false, error: 'Slide ' + (i + 1) + ' is not an object' };
        }
        // Validate blocks array exists
        if (!Array.isArray(slide.blocks)) {
          return { valid: false, error: 'Slide ' + (i + 1) + ' is missing blocks array' };
        }
        // Check blocks limit
        if (slide.blocks.length > MAX_BLOCKS_PER_SLIDE) {
          return { valid: false, error: 'Slide ' + (i + 1) + ' has too many blocks (max: ' + MAX_BLOCKS_PER_SLIDE + ')' };
        }
        // Truncate oversized strings in blocks
        for (var j = 0; j < slide.blocks.length; j++) {
          var block = slide.blocks[j];
          if (block.text && typeof block.text === 'string') {
            block.text = truncateString(block.text, MAX_STRING_LENGTH);
          }
          if (block.items && Array.isArray(block.items)) {
            for (var k = 0; k < block.items.length; k++) {
              block.items[k] = truncateString(block.items[k], MAX_STRING_LENGTH);
            }
          }
          if (block.code && typeof block.code === 'string') {
            block.code = truncateString(block.code, MAX_STRING_LENGTH * 10);
          }
        }
      }
      return { valid: true };
    }

    function importJson(jsonStr) {
      var slides;
      try {
        slides = JSON.parse(jsonStr);
      } catch (e) {
        setImportStatus('Invalid JSON: ' + e.message, 'error');
        log('JSON parse error: ' + e.message);
        return;
      }

      var validation = validateSlides(slides);
      if (!validation.valid) {
        setImportStatus(validation.error, 'error');
        log('Validation error: ' + validation.error);
        return;
      }

      setImportStatus('Generating ' + slides.length + ' slides...', 'waiting');
      log('Importing ' + slides.length + ' slides from JSON');

      parent.postMessage({
        pluginMessage: {
          type: 'generate-slides',
          slides: slides
        }
      }, '*');
    }

    function connect(host, port, secret) {
      if (host === undefined) host = currentHost;
      if (port === undefined) port = currentPort;
      if (secret === undefined) secret = currentSecret;

      var parsedPort = parseInt(port, 10);
      currentHost = host && String(host).trim() ? String(host).trim() : DEFAULT_HOST;
      currentPort = Number.isFinite(parsedPort) ? parsedPort : DEFAULT_PORT;
      currentSecret = secret || '';
      authenticated = false;

      safeSet(HOST_KEY, currentHost);
      safeSet(PORT_KEY, String(currentPort));
      safeSet(SECRET_KEY, currentSecret);

      updateRemoteWarning();

      if (ws) {
        ws.onclose = null;
        ws.onerror = null;
        ws.onmessage = null;
        ws.onopen = null;
        ws.close();
      }

      setStatus('Connecting to ws://' + currentHost + ':' + currentPort + '...', 'waiting');
      log('Connecting to ws://' + currentHost + ':' + currentPort);

      try {
        ws = new WebSocket('ws://' + currentHost + ':' + currentPort);

        ws.onopen = function() {
          log('Connected to CLI');
          // Start timeout to detect old CLI that doesn't send hello
          startHelloTimeout();
          // Send auth message if secret is provided
          if (currentSecret) {
            log('Sending authentication...');
            setStatus('Authenticating...', 'waiting');
            ws.send(JSON.stringify({ type: 'auth', secret: currentSecret }));
          } else {
            // No secret - server may or may not require auth
            // Try to auth anyway (server will respond with auth-ok even without secret if no auth required)
            ws.send(JSON.stringify({ type: 'auth', secret: '' }));
            setStatus('Connected to ws://' + currentHost + ':' + currentPort + ' - Waiting for slides...', 'connected');
            authenticated = true;
          }
        };

        ws.onmessage = function(event) {
          try {
            var msg = JSON.parse(event.data);
            log('Received: ' + msg.type);

            // Handle hello message from CLI (version check)
            if (msg.type === 'hello' && msg.cliVersion) {
              handleHelloMessage(msg);
              return;
            }

            // Handle auth responses
            if (msg.type === 'auth-ok') {
              authenticated = true;
              setStatus('Connected to ws://' + currentHost + ':' + currentPort + ' - Waiting for slides...', 'connected');
              log('Authentication successful');
              return;
            }
            if (msg.type === 'auth-error') {
              authenticated = false;
              setStatus('Authentication failed: ' + (msg.message || 'Invalid secret'), 'error');
              log('Authentication failed: ' + (msg.message || 'Invalid secret'));
              return;
            }

            // Only process slides if authenticated
            if (msg.type === 'generate-slides') {
              if (!Array.isArray(msg.slides)) {
                log('Invalid message: slides is not an array');
                return;
              }
              // Validate incoming slides
              var validation = validateSlides(msg.slides);
              if (!validation.valid) {
                log('Rejected payload: ' + validation.error);
                return;
              }
              log('Generating ' + msg.slides.length + ' slides...');
              parent.postMessage({ pluginMessage: msg }, '*');
            }
          } catch (e) {
            log('Error parsing message: ' + e);
          }
        };

        ws.onclose = function(event) {
          authenticated = false;
          clearHelloTimeout();
          dismissVersionWarning();
          if (event.code === 4001) {
            setStatus('Authentication timeout', 'error');
            log('Authentication timeout - provide the secret from CLI');
            return;
          }
          if (event.code === 4002) {
            setStatus('Invalid secret', 'error');
            log('Invalid secret - check the secret displayed in CLI');
            return;
          }
          if (autoConnect && activeTab === 'websocket') {
            setStatus('Disconnected - Reconnecting to ws://' + currentHost + ':' + currentPort + '...', 'disconnected');
            log('Disconnected, retrying in 3s...');
            setTimeout(function() { connect(currentHost, currentPort, currentSecret); }, 3000);
          } else {
            setStatus('Disconnected', 'disconnected');
          }
        };

        ws.onerror = function() {
          log('WebSocket error');
        };
      } catch (e) {
        log('Connection failed: ' + e);
        if (autoConnect && activeTab === 'websocket') {
          setTimeout(function() { connect(currentHost, currentPort, currentSecret); }, 3000);
        }
      }
    }

    window.onmessage = function(event) {
      var msg = event.data.pluginMessage;
      if (msg) {
        if (msg.type === 'success') {
          log('Success! Generated ' + msg.count + ' slides');
          if (activeTab === 'import') {
            setImportStatus('Success! Generated ' + msg.count + ' slides', 'connected');
          }
        } else if (msg.type === 'error') {
          log('Error: ' + msg.message);
          if (activeTab === 'import') {
            setImportStatus('Error: ' + msg.message, 'error');
          }
        }
      }
    };

    // Tab switching
    tabs.forEach(function(tab) {
      tab.addEventListener('click', function() {
        switchTab(tab.getAttribute('data-tab'));
      });
    });

    // Import JSON button
    importButton.addEventListener('click', function() {
      var jsonStr = jsonInput.value.trim();
      if (!jsonStr) {
        setImportStatus('Please enter or paste JSON', 'error');
        return;
      }
      importJson(jsonStr);
    });

    // Load file button
    loadFileButton.addEventListener('click', function() {
      fileInput.click();
    });

    // File input handler
    fileInput.addEventListener('change', function(event) {
      var file = event.target.files[0];
      if (!file) return;

      var reader = new FileReader();
      reader.onload = function(e) {
        var content = e.target.result;
        jsonInput.value = content;
        log('Loaded file: ' + file.name);
        importJson(content);
      };
      reader.onerror = function() {
        setImportStatus('Failed to read file', 'error');
        log('File read error');
      };
      reader.readAsText(file);
      fileInput.value = '';
    });

    loadStoredConnection();

    form.addEventListener('submit', function(event) {
      event.preventDefault();
      connect(hostInput.value, portInput.value, secretInput.value);
    });

    connectButton.addEventListener('click', function() {
      connect(hostInput.value, portInput.value, secretInput.value);
    });

    // Update warning when host input changes
    hostInput.addEventListener('input', function() {
      var host = hostInput.value.trim() || DEFAULT_HOST;
      if (isLoopbackHost(host)) {
        remoteWarning.classList.remove('visible');
      } else {
        remoteWarning.classList.add('visible');
      }
    });

    // Only auto-connect if on websocket tab
    if (activeTab === 'websocket') {
      connect(currentHost, currentPort, currentSecret);
    }
  </script>
</body>
</html>
